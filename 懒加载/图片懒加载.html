<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>图片懒加载</title>
    <script src="lazyload.js"></script>
</head>
<style>
    .test {
        width: 100%;
        height: auto;
    }

    .test img {
        height: 400px;
        width: 100%;
        object-fit: cover;
    }
</style>
<body>
<div class="test">
    <p>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说
        ，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，
        不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，
        如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，
        进而可能会引发内存泄漏
        。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。
        因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，
        它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。
        另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是</p>
    <p>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说
        ，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，
        不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，
        如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，
        进而可能会引发内存泄漏
        。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。
        因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，
        它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。
        另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是</p>
    <p>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说
        ，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，
        不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，
        如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，
        进而可能会引发内存泄漏
        。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。
        因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，
        它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。
        另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是</p>
    <p>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说
        ，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，
        不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，
        如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，
        进而可能会引发内存泄漏
        。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。
        因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，
        它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。
        另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是</p>
    <p>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说
        ，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，
        不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，
        如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，
        进而可能会引发内存泄漏
        。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。
        因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，
        它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。
        另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是</p>
    <p>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说
        ，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，
        不考虑该对象还存在于 WeakSet 之中。 这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，
        如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，
        进而可能会引发内存泄漏
        。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。
        因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，
        它在 WeakSet 里面的引用就会自动消失。 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。
        另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是</p>
    <img src="" data-src="./1.jpg"/>
    <img src="" data-src="./2.png"/>
    <img src="" data-src="./3.png"/>
    <img src="" data-src="./4.png"/>

</div>
<script>
    const imgs = document.querySelectorAll('img[data-src]')
    const callback = (entries) => {
        entries.forEach(entry => {
            console.log(entry)
            if (entry.isIntersecting) {
             let image = entry.target
                image.src = image.dataset.src
                image.removeAttribute("data-src")
                io.unobserve(image)
            }
        })
    }
    const io = new IntersectionObserver(callback)
     imgs.forEach(el=>{
         // 观察加载的每一张图片
         io.observe(el)
     })

</script>
</body>
</html>
